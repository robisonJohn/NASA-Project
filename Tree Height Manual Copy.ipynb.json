{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Identifying Tree Heights\n",
    "\n",
    "\n",
    "#IMPORTING REQUIRED MODULES\n",
    "\n",
    "\n",
    "#subroutine for designating a code block\n",
    "def designate(title, section='main'):\n",
    "    \"\"\"Designate a code block with a title so that the code may be hidden and reopened.\n",
    "    \n",
    "    Arguments:\n",
    "        title: str, title for code block\n",
    "        section='main': str, section title\n",
    "        \n",
    "    Returns:\n",
    "        None\n",
    "    \"\"\"\n",
    "    \n",
    "    # begin designation\n",
    "    designation = ' ' * 15\n",
    "    \n",
    "    # if marked for user parameters\n",
    "    if section == 'settings':\n",
    "        \n",
    "        # begin designation with indicator\n",
    "        designation = '*** settings -----> '\n",
    "    \n",
    "    # add code designator\n",
    "    designation += '^ [code] (for {}: {})'.format(section, title)\n",
    "    \n",
    "    # print\n",
    "    print(designation)\n",
    "    \n",
    "    return None\n",
    "\n",
    "designate('designating hidden code blocks', 'designation')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('importing Python modules')\n",
    "\n",
    "# import os and sys modules for system controls\n",
    "import os\n",
    "import sys\n",
    "\n",
    "# import requests and json modules for making API requests\n",
    "import requests\n",
    "import json\n",
    "\n",
    "# set runtime warnings to ignore\n",
    "import warnings\n",
    "\n",
    "# import fuzzywuzzy for fuzzy name matching\n",
    "from fuzzywuzzy import fuzz\n",
    "\n",
    "# import datetime module for manipulating date and time formats\n",
    "from datetime import datetime, timedelta\n",
    "\n",
    "# import numpy module and math module for mathematical functions\n",
    "from numpy import sqrt, pi, average, std, histogram\n",
    "\n",
    "# import pandas for date table manipulation\n",
    "import pandas\n",
    "\n",
    "# import zipfile to create zip files\n",
    "from zipfile import ZipFile"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('importing Python plotting modules')\n",
    "\n",
    "# import bokeh for plotting graphs\n",
    "from bokeh.plotting import figure\n",
    "from bokeh.io import output_notebook, show\n",
    "from bokeh.models import HoverTool, ColumnDataSource, Whisker, TeeHead\n",
    "from bokeh.models.formatters import DatetimeTickFormatter\n",
    "\n",
    "# import ipyleaflet for plotting maps\n",
    "from ipyleaflet import Map, Marker, basemaps, CircleMarker, LayerGroup\n",
    "from ipyleaflet import WidgetControl, ScaleControl, FullScreenControl\n",
    "\n",
    "# import iPython for javascript based notebook controls\n",
    "from IPython.display import Javascript, display, Image, FileLink\n",
    "\n",
    "# import ipywidgets for additional widgets\n",
    "from ipywidgets import Label, HTML, Button, Layout, Output, HBox, VBox, Box"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('inferring fuzzy match', 'tools')\n",
    "\n",
    "# subroutine for fuzzy matching\n",
    "def infer(text, options):\n",
    "    \"\"\"Infer closest match of text from a list of options.\n",
    "    \n",
    "    Arguments:\n",
    "        text: str, entered text\n",
    "        options: list of str, the options\n",
    "        \n",
    "    Returns:\n",
    "        str, the closest match\n",
    "    \"\"\"\n",
    "    \n",
    "    # perform fuzzy search to get closest match\n",
    "    fuzzies = [(option, fuzz.ratio(text, option)) for option in options]\n",
    "    fuzzies.sort(key=lambda pair: pair[1], reverse=True)\n",
    "    inference = fuzzies[0][0]\n",
    "    \n",
    "    return inference"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('truncating field names', 'tools')\n",
    "\n",
    "# truncate field names to first capital\n",
    "def truncate(name, size=5, minimum=4, maximum=15):\n",
    "    \"\"\"Truncate a name to the first captial letter past the minimum.\n",
    "    \n",
    "    Arguments:\n",
    "        name: str, the name for truncation\n",
    "        size: the final size of the truncation\n",
    "        minimum=4: int, minimum length of name\n",
    "        maximum=15: int, maximum length of name\n",
    "        \n",
    "    Returns\n",
    "        str, truncated name\n",
    "    \"\"\"\n",
    "    \n",
    "    # chop name at maximum and capitalize\n",
    "    name = name[-maximum:]\n",
    "    name = name[0].capitalize() + name[1:]\n",
    "    \n",
    "    # make stub starting at minimum length\n",
    "    length = minimum\n",
    "    stub = name[-length:]\n",
    "    while not stub[0].isupper():\n",
    "        \n",
    "        # add to length\n",
    "        length += 1\n",
    "        stub = name[-length:]\n",
    "        \n",
    "    # only pass size\n",
    "    stub = stub[:size]\n",
    "        \n",
    "    return stub"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('entitling a name by capitalizing', 'tools')\n",
    "\n",
    "# entitle function to capitalize a word for a title\n",
    "def entitle(word):\n",
    "    \"\"\"Entitle a word by capitalizing the first letter.\n",
    "    \n",
    "    Arguments:\n",
    "        word: str\n",
    "        \n",
    "    Returns:\n",
    "        str\n",
    "    \"\"\"\n",
    "    \n",
    "    # capitalize first letter\n",
    "    word = word[0].upper() + word[1:]\n",
    "    \n",
    "    return word"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('resolving country name and code', 'tools')\n",
    "\n",
    "# resolving country name and codes\n",
    "def resolve(country, code):\n",
    "    \"\"\"Resolve the country code from given information.\n",
    "    \n",
    "    Arguments:\n",
    "        country: str, country name as input\n",
    "        code: str, country code as input\n",
    "        \n",
    "    Returns:\n",
    "        (str, str) tuple, the country name and country code\n",
    "    \"\"\"\n",
    "    \n",
    "    # check for code\n",
    "    if code:\n",
    "        \n",
    "        # find closest matching code\n",
    "        code = infer(code, [member for member in codes.values()])\n",
    "        country = countries[code]\n",
    "    \n",
    "    # if no code, but a country is given\n",
    "    if not code and country:\n",
    "        \n",
    "        # find closest matching country\n",
    "        country = infer(country, [member for member in codes.keys()])\n",
    "        code = codes[country]\n",
    "    \n",
    "    # if there's no code, check the country\n",
    "    if not code and not country:\n",
    "        \n",
    "        # default to all countries\n",
    "        country = 'All countries'\n",
    "        code = ''\n",
    "    \n",
    "    return country, code"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('scanning notebook for cells', 'introspection')\n",
    "\n",
    "# scan notebook for cell information\n",
    "def scan():\n",
    "    \"\"\"Scan the notebook and collect cell information.\n",
    "\n",
    "    Arguments:\n",
    "        None\n",
    "\n",
    "    Returns:\n",
    "        list of dicts\n",
    "    \"\"\"\n",
    "\n",
    "    # open the notebook file \n",
    "    with open('mosquitoes.ipynb', 'r', encoding='utf-8') as pointer:\n",
    "        \n",
    "        # and read its contents\n",
    "        contents = json.loads(pointer.read())\n",
    "\n",
    "    # get all cells\n",
    "    cells = contents['cells']\n",
    "\n",
    "    return cells"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('defining global variables')\n",
    "\n",
    "# ignore runtime warnings\n",
    "warnings.filterwarnings('ignore')\n",
    "\n",
    "# set pandas optinos\n",
    "pandas.set_option(\"display.max_rows\", None)\n",
    "pandas.set_option(\"display.max_columns\", None)\n",
    "\n",
    "# make doppelganger for navigation\n",
    "doppelganger = scan()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('import status')\n",
    "\n",
    "# print status\n",
    "print('modules imported.')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Notes on Navigation"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('looking for particular cell', 'navigation')\n",
    "\n",
    "# function to look for cells with a particular text snippet\n",
    "def look(text):\n",
    "    \"\"\"Look for a particular text amongst the cells.\n",
    "    \n",
    "    Arguments:\n",
    "        text: str, the text to search for\n",
    "        \n",
    "    Returns:\n",
    "        list of int, the cell indices.\n",
    "    \"\"\"\n",
    "    \n",
    "    # search for cells \n",
    "    indices = []\n",
    "    for index, cell in enumerate(doppelganger):\n",
    "        \n",
    "        # search for text in source\n",
    "        if any([text in line.replace(\"'{}'\".format(text), '') for line in cell['source']]):\n",
    "            \n",
    "            # add to list\n",
    "            indices.append(index)\n",
    "            \n",
    "    return indices"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('jumping to a particular cell', 'navigation')\n",
    "\n",
    "# jump to a particular cell\n",
    "def jump(identifier):\n",
    "    \"\"\"Jump to a particular cell.\n",
    "    \n",
    "    Arguments:\n",
    "        identifier: int or str\n",
    "        \n",
    "    Returns:\n",
    "        None\n",
    "    \"\"\"\n",
    "    \n",
    "    # try to look for a string\n",
    "    try:\n",
    "        \n",
    "        # assuming string, take first index with string\n",
    "        index = look(identifier)\n",
    "        \n",
    "    # otherwise assume int\n",
    "    except (TypeError, IndexError):\n",
    "        \n",
    "        # index is identifier\n",
    "        index = identifier \n",
    "    \n",
    "    # scroll to cell\n",
    "    command = 'IPython.notebook.scroll_to_cell({})'.format(index)\n",
    "    display(Javascript(command))\n",
    "    \n",
    "    return"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('executing cell range by text', 'navigation')\n",
    "\n",
    "# execute cell range command\n",
    "def execute(start, finish):\n",
    "    \"\"\"Execute a cell range based on text snippets.\n",
    "    \n",
    "    Arguments:\n",
    "        start: str, text from beginning cell of range\n",
    "        finish: str, text from ending cell of range\n",
    "        \n",
    "    Returns:\n",
    "        None\n",
    "    \"\"\"\n",
    "    \n",
    "    # find start and finish indices, adding 1 to be inclusive\n",
    "    opening = look(start)[0] \n",
    "    closing = look(finish)[0]\n",
    "    bracket = (opening, closing)\n",
    "    \n",
    "    # make command\n",
    "    command = 'IPython.notebook.execute_cell_range' + str(bracket)\n",
    "    \n",
    "    # perform execution\n",
    "    display(Javascript(command))\n",
    "    \n",
    "    return None"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('refreshing cells by relative position', 'navigation')\n",
    "\n",
    "# execute cell range command\n",
    "def refresh(start, finish=None):\n",
    "    \"\"\"Refresh a particular cell relative to current cell.\n",
    "    \n",
    "    Arguments:\n",
    "        start: int, the first cell offset\n",
    "        finish=None: int, the second cell offset\n",
    "        \n",
    "    Returns:\n",
    "        None\n",
    "    \"\"\"\n",
    "    \n",
    "    # make offset into a string\n",
    "    stringify = lambda offset: str(offset) if offset < 0 else '+' + str(offset)\n",
    "    \n",
    "    # default finish to start\n",
    "    finish = finish or start\n",
    "    \n",
    "    # make command\n",
    "    command = 'IPython.notebook.execute_cell_range('\n",
    "    command += 'IPython.notebook.get_selected_index()' + stringify(start) + ','\n",
    "    command += 'IPython.notebook.get_selected_index()' + stringify(finish + 1) + ')'\n",
    "    \n",
    "    # perform execution\n",
    "    display(Javascript(command))\n",
    "    \n",
    "    return None"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('revealing open cells', 'navigation')\n",
    "\n",
    "# outline headers\n",
    "def reveal(cells):\n",
    "    \"\"\"Outline the headers and collapsed or uncollapsed state.\n",
    "    \n",
    "    Arguments:\n",
    "        cells: dict\n",
    "        \n",
    "    Returns:\n",
    "        list of int, the indices of visible cells\n",
    "    \"\"\"\n",
    "    \n",
    "    # search through all cells for headers\n",
    "    indices = []\n",
    "    visible = True\n",
    "    for index, cell in enumerate(cells):\n",
    "        \n",
    "        # check for text\n",
    "        header = False\n",
    "        if any(['###' in text for text in cell['source']]):\n",
    "        \n",
    "            # check for header and visible state\n",
    "            header = True\n",
    "            visible = True\n",
    "            if 'heading_collapsed' in cell['metadata'].keys(): \n",
    "\n",
    "                # set visible flag\n",
    "                visible = not cell['metadata']['heading_collapsed']\n",
    "\n",
    "        # if either header or visible\n",
    "        if header or visible: \n",
    "\n",
    "            # add to indices\n",
    "            indices.append(index)\n",
    "            \n",
    "    return indices"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('gauging cell size', 'navigation')\n",
    "\n",
    "# measure a cell's line count and graphics\n",
    "def gauge(cell):\n",
    "    \"\"\"Gauge a cell's line count and graphic size.\n",
    "    \n",
    "    Arguments:\n",
    "        cell: cell dict\n",
    "        \n",
    "    Returns:\n",
    "        (int, boolean) tuple, line count and graphic boolean\n",
    "    \"\"\"\n",
    "    \n",
    "    # check for display data\n",
    "    graphic = False\n",
    "    displays = [entry for entry in cell.setdefault('outputs', []) if entry['output_type'] == 'display_data']\n",
    "    if len(displays) > 0:\n",
    "        \n",
    "        # check for many displays or one long one\n",
    "        if len(displays) > 2 or 'â€¦' in displays[0]['data']['text/plain'][0]:\n",
    "\n",
    "            # switch graphic to true\n",
    "            graphic = True\n",
    "\n",
    "    # determine total lines of text in source, 2 by default\n",
    "    length = 2\n",
    "    \n",
    "    # determine executions\n",
    "    executions = [entry for entry in cell.setdefault('outputs', []) if entry['output_type'] == 'execute_result']\n",
    "    for execution in executions:\n",
    "        \n",
    "        # add to length\n",
    "        length += execution['execution_count']\n",
    "    \n",
    "    # check hide-input state\n",
    "    if not cell['metadata'].setdefault('hide_input', False):\n",
    "        \n",
    "        # add lines to source\n",
    "        source = cell['source']\n",
    "        for line in source:\n",
    "\n",
    "            # split on newlines\n",
    "            length += sum([int(len(line) / 100) + 1 for line in line.split('\\n')])\n",
    "\n",
    "    return length, graphic"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('bookmarking cells for screenshotting', 'navigation')\n",
    "\n",
    "# bookmark which cells to scroll to\n",
    "def bookmark(cells):\n",
    "    \"\"\"Bookmark which cells to scroll to.\n",
    "\n",
    "    Arguments:\n",
    "        cells: list of dicts\n",
    "        visibles: list of ints\n",
    "\n",
    "    Returns:\n",
    "        list of ints\n",
    "    \"\"\"\n",
    "\n",
    "    # set page length criterion and initialize counters\n",
    "    criterion = 15\n",
    "    accumulation = criterion + 1\n",
    "\n",
    "    # determine scroll indices\n",
    "    bookmarks = []\n",
    "    visibles = reveal(cells)\n",
    "    for index in visibles:\n",
    "\n",
    "        # measure cell and add to total\n",
    "        cell = cells[index]\n",
    "        length, graphic = gauge(cell)\n",
    "        accumulation += length\n",
    "        \n",
    "        # compare to criterion\n",
    "        if accumulation > criterion or graphic:\n",
    "\n",
    "            # add to scrolls and reset\n",
    "            bookmarks.append(index)\n",
    "            accumulation = length\n",
    "\n",
    "            # for a graphic, make sure accumulation is already maxed\n",
    "            if graphic:\n",
    "                \n",
    "                # add to accumulation\n",
    "                accumulation = criterion + 1\n",
    "\n",
    "    return bookmarks"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('describing cell contents', 'navigation')\n",
    "\n",
    "# describe the cells\n",
    "def describe(*numbers):\n",
    "    \"\"\"Describe the list of cells by printing cell summaries.\n",
    "\n",
    "    Arguments:\n",
    "        numbers: unpacked list of ints\n",
    "\n",
    "    Returns:\n",
    "        None\n",
    "    \"\"\"\n",
    "\n",
    "    # get cells and analyze\n",
    "    visibles = reveal(doppelganger)\n",
    "    bookmarks = bookmark(doppelganger)\n",
    "\n",
    "    # print cell metadata\n",
    "    for index, cell in enumerate(doppelganger):\n",
    "\n",
    "        # construct stars to mark visible and bookmark statuses\n",
    "        stars = '' + '*' * (int(index in visibles) + int(index in bookmarks))\n",
    "\n",
    "        # check in numbers\n",
    "        if len(numbers) < 1 or index in numbers:\n",
    "        \n",
    "            # print metadata\n",
    "            print(' \\n{} cell {}:'.format(stars, index))\n",
    "            print(cell['cell_type'])\n",
    "            print(cell['source'][0][:100])\n",
    "            print(cell['metadata'])\n",
    "            print([key for key in cell.keys()])\n",
    "            if 'outputs' in cell.keys():\n",
    "\n",
    "                # print outputs\n",
    "                print('outputs:')\n",
    "                for entry in cell['outputs']:\n",
    "\n",
    "                    # print keys\n",
    "                    print('\\t {}, {}'.format(entry['output_type'], [key for key in entry.keys()]))\n",
    "\n",
    "    return None"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('propagating setting changes across cells', 'buttons')\n",
    "\n",
    "# def propagate\n",
    "def propagate(start, finish, finishii, descriptions=['Apply', 'Propagate', 'Both']):\n",
    "    \"\"\"Propagate changes across all code cells given by the headings.\n",
    "    \n",
    "    Arguments:\n",
    "        start: str, top header\n",
    "        finish: str, update stopping point\n",
    "        finishii: str, propagate stopping point\n",
    "        descriptions: list of str\n",
    "        \n",
    "    Returns:\n",
    "        None\n",
    "    \"\"\"\n",
    "    \n",
    "    # define jump points\n",
    "    cues = [(start, finish), (finish, finishii), (start, finishii)]\n",
    "    \n",
    "    # make buttons\n",
    "    buttons = []\n",
    "    buttoning = lambda start, finish: lambda _: execute(start, finish)\n",
    "    for description, cue in zip(descriptions, cues):\n",
    "\n",
    "        # make button\n",
    "        button = Button(description=description)\n",
    "        button.on_click(buttoning(*cue))\n",
    "        buttons.append(button)\n",
    "\n",
    "    # display\n",
    "    display(HBox(buttons))\n",
    "    \n",
    "    return None"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('navigating to main sections', 'buttons')\n",
    "\n",
    "# present buttons to jump to particular parts of the notebook\n",
    "def navigate():\n",
    "    \"\"\"Guide the user towards regression sections with buttons.\n",
    "    \n",
    "    Arguments:\n",
    "        None\n",
    "        \n",
    "    Returns:\n",
    "        None\n",
    "    \"\"\"\n",
    "\n",
    "    # define jump points\n",
    "    descriptions = ['Top', 'Settings', 'Filter', 'Graphs', 'Sources', 'Map', 'Bottom']\n",
    "    cues = ['# Trees in my Country', '### Setting the Parameters', '### Filtering Records']\n",
    "    cues += ['### Plotting Tree Counts over Time', '### Plotting Larvae Counts by Water Source']\n",
    "    cues += ['### Plotting Sampling Locations on a Map', '### Thank You!']\n",
    "    \n",
    "    # make buttons\n",
    "    buttons = []\n",
    "    buttoning = lambda cue: lambda _: jump(cue)\n",
    "    for description, cue in zip(descriptions, cues):\n",
    "\n",
    "        # make button\n",
    "        button = Button(description=description, layout=Layout(width='140px'))\n",
    "        button.on_click(buttoning(cue))\n",
    "        buttons.append(button)\n",
    "\n",
    "    # display\n",
    "    display(HBox(buttons))\n",
    "    \n",
    "    return None"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Getting Started"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('navigation buttons')\n",
    "\n",
    "# set navigation buttons\n",
    "navigate()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Table of GLOBE Countries"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#list of GLOBE supporting countries and codes\n",
    "\n",
    "designate('extracting all GLOBE countries')\n",
    "\n",
    "# retrieve list of GLOBE countries and country codes from the API\n",
    "url = 'https://api.globe.gov/search/dev/country/all/'\n",
    "request = requests.get(url)\n",
    "raw = json.loads(request.text)\n",
    "countries = [record for record in raw['results']]\n",
    "\n",
    "# create codes reference for later\n",
    "codes = {record['countryName']: record['id'] for record in countries}\n",
    "countries = {record['id']: record['countryName'] for record in countries}\n",
    "\n",
    "# make table\n",
    "table = [item for item in codes.items()]\n",
    "table.sort(key=lambda item: item[0])\n",
    "\n",
    "# print table\n",
    "print('{} GLOBE countries:'.format(len(table)))\n",
    "table"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Setting the Parameters"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Set the parameters for desired country and date range here\n",
    "\n",
    "designate('setting the country and date range', 'settings')\n",
    "\n",
    "# set the desired country name (refer to table above for exact spelling)\n",
    "country = 'Thailand'\n",
    "\n",
    "# or set the country code (the country code will override the name, unless it is set to None or '')\n",
    "code = ''\n",
    "\n",
    "# set beginning and ending dates in 'YYYY-mm-dd' format\n",
    "beginning = '2019-01-01'\n",
    "ending = '2020-01-01'"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('applying setting changes or propagating throughout notebook')\n",
    "\n",
    "# propagate changes\n",
    "propagate('### Setting the Parameters', '### Making the API Call', '### Exporting to PDF')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('calling the api', 'api')\n",
    "\n",
    "# call the api with protocol and country code\n",
    "def call(protocol, code, beginning, ending, sample=False):\n",
    "    \"\"\"Call the api:\n",
    "    \n",
    "    Arguments:\n",
    "        protocol: str, the protocol\n",
    "        code: str, the country code\n",
    "        beginning: str, the beginning date\n",
    "        ending: str, the ending date\n",
    "        sample=False: boolean, only get small sampling?\n",
    "        \n",
    "    Returns:\n",
    "        list of dicts, the records\n",
    "    \"\"\"\n",
    "    \n",
    "    # default to all countries unless a code is specified\n",
    "    extension = 'country/' if code else ''\n",
    "    extensionii = '&countrycode=' + code if code else ''\n",
    "    \n",
    "    # assemble the url for the API call \n",
    "    url = 'https://api.globe.gov/search/v1/measurement/protocol/measureddate/' + extension\n",
    "    url += '?protocols=' + protocol\n",
    "    url += '&startdate=' + beginning \n",
    "    url += '&enddate=' + ending\n",
    "    url += extensionii\n",
    "\n",
    "    # geojson parameter toggles between formats\n",
    "    url += '&geojson=FALSE'\n",
    "    \n",
    "    # sample parameter returns small sample set if true\n",
    "    url += '&sample=' + str(sample).upper()\n",
    "\n",
    "    # make the API call and return the raw results\n",
    "    request = requests.get(url)\n",
    "    raw = json.loads(request.text)\n",
    "    \n",
    "    return raw"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('resolving user settings')\n",
    "\n",
    "# define primary protocol name and tree field\n",
    "tree_heights = 'biometry_trees'\n",
    "land_covers = 'vegetation_covers:ground_co ver_plus_count'\n",
    "\n",
    "# resolve country and code to default values\n",
    "country, code = resolve(country, code)\n",
    "\n",
    "# default beginning to first day of GLOBE and ending to current date if unspecified\n",
    "beginning = beginning or '1995-04-22'\n",
    "ending = ending or str(datetime.now().date())\n",
    "\n",
    "# make api call to get number of records\n",
    "print('checking number of records...')\n",
    "raw = call(tree_heights, code, beginning, ending, sample=True)\n",
    "count = raw['count']\n",
    "print('{} {} records from {} ({}), from {} to {}'.format(count, tree_heights, country, code, beginning, ending))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('navigation buttons')\n",
    "\n",
    "# set navigation buttons\n",
    "navigate()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Making the API Call"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('retrieving tree height habitat data from the API')\n",
    "\n",
    "# make api call\n",
    "print('making request...')\n",
    "raw = call(tree_height, code, beginning, ending, sample=False)\n",
    "results = [record for record in raw['results']]\n",
    "\n",
    "# report number of records found\n",
    "print('{} records from {}'.format(len(results), country))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('checking records length')\n",
    "\n",
    "# raise assertion error on zero records\n",
    "try:\n",
    "    \n",
    "    # assert length > 0\n",
    "    assert len(results) > 0\n",
    "    \n",
    "# otherwise\n",
    "except AssertionError:\n",
    "    \n",
    "    # raise the error with a message\n",
    "    message = '* Error! * No records returned'\n",
    "    raise Exception(message)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('navigation buttons')\n",
    "\n",
    "# set navigation buttons\n",
    "navigate()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Simplifying the Records"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('viewing example original record')\n",
    "\n",
    "# view first record\n",
    "results[0]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('record flattening records', 'processing')\n",
    "\n",
    "# function to flatten a nested list into a single-level structure\n",
    "def flatten(record, label=None):\n",
    "    \"\"\"Flatten each record into a single level.\n",
    "\n",
    "    Arguments:\n",
    "        record: dict, a record\n",
    "        label: str, key from last nesting\n",
    "\n",
    "    Returns:\n",
    "        dict\n",
    "    \"\"\"\n",
    "\n",
    "    # initiate dictionary\n",
    "    flattened = {}\n",
    "\n",
    "    # try to flatten the record\n",
    "    try:\n",
    "\n",
    "        # go through each field\n",
    "        for field, info in record.items():\n",
    "\n",
    "            # and flatten the smaller records found there\n",
    "            flattened.update(flatten(info, field))\n",
    "\n",
    "    # otherwise record is a terminal entry\n",
    "    except AttributeError:\n",
    "\n",
    "        # so update the dictionary with the record\n",
    "        flattened.update({label: record})\n",
    "\n",
    "    return flattened"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('for flattening all records')\n",
    "\n",
    "# flatten all results\n",
    "flats = [flatten(record) for record in results]\n",
    "\n",
    "# print status\n",
    "print('records flattened.')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('abbreviating fields')\n",
    "\n",
    "# define abbreviations dictionary\n",
    "abbreviations = {}\n",
    "abbreviations['count'] = 'treehabitatmapperLarvaeCount'\n",
    "abbreviations['genus'] = 'treehabitatmapperGenus'\n",
    "abbreviations['source'] = 'treehabitatmapperWaterSource'\n",
    "abbreviations['stage'] = 'treehabitatmapperLastIdentifyStage'\n",
    "abbreviations['type'] = 'treehabitatmapperWaterSourceType'\n",
    "abbreviations['measured'] = 'treehabitatmapperMeasuredAt'\n",
    "\n",
    "\n",
    "# for each record\n",
    "for record in flats:\n",
    "    \n",
    "    # and each abbreviation\n",
    "    for abbreviation, field in abbreviations.items():\n",
    "        \n",
    "        # copy new field from old, or None if nonexistent\n",
    "        record[abbreviation] = record.setdefault(field, None)\n",
    "        del(record[field])\n",
    "        \n",
    "# print status\n",
    "print('fields abbreviated.')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('converting times')\n",
    "\n",
    "# convert each record\n",
    "for record in flats:\n",
    "\n",
    "    # convert the date string to date object and normalize based on partitioning\n",
    "    record['time'] = datetime.strptime(record['measured'], \"%Y-%m-%dT%H:%M:%S\")\n",
    "    record['date'] = record['time'].date()\n",
    "    \n",
    "    # convert the date string to date object and correct for longitude\n",
    "    zone = int(round(record['longitude'] * 24 / 360, 0))\n",
    "    record['hour'] = record['time'] + timedelta(hours=zone)\n",
    "    \n",
    "# status\n",
    "print('times converted.')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('parsing tree biometry')\n",
    "\n",
    "# correct biometry based on last stage\n",
    "for record in flats:\n",
    "    \n",
    "    # check biometry\n",
    "    if record['biometry'] is None:\n",
    "        \n",
    "        # check last stage\n",
    "        if record['stage'] in (None, u'identify'):\n",
    "            \n",
    "            # correct genus to 'Unidentified'\n",
    "            record['genus'] = 'Unknown'\n",
    "            \n",
    "        # otherwise\n",
    "        else:\n",
    "            \n",
    "            # correct biometry to 'Other'\n",
    "            record['biometry'] = 'Other'\n",
    "\n",
    "# establish biometry\n",
    "classification = ['dominant_genus', 'dominant_species', 'codominant_genus', 'codominant_species', 'mixed_dominant']\n",
    "\n",
    "\n",
    "# status\n",
    "print('biometry parsed.')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('constructing latlon string', 'processing')\n",
    "    \n",
    "# specify the location code for the photo based on its geo coordinates\n",
    "def localize(latitude, longitude):\n",
    "    \"\"\"Specify the location code for the photo naming convention.\n",
    "    \n",
    "    Arguments:\n",
    "        latitude: float, the latitude\n",
    "        longitude: float, the longitude\n",
    "        \n",
    "    Returns:\n",
    "        str, the latlon code\n",
    "    \"\"\"\n",
    "    \n",
    "    # get latlon codes based on < 0 query\n",
    "    latitudes = {True: 'S', False: 'N'}\n",
    "    longitudes = {True: 'W', False: 'E'}\n",
    "    \n",
    "    # make latlon code from letter and rounded geocoordinate with 3 places\n",
    "    latlon = latitudes[latitude < 0] + ('000' + str(abs(int(latitude))))[-3:]\n",
    "    latlon += longitudes[longitude < 0] + ('000' + str(abs(int(longitude))))[-3:]\n",
    "    \n",
    "    return latlon"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('applying naming convention subroutine')\n",
    "\n",
    "# apply the naming convention to a photo url to make a file name\n",
    "def apply(urls, code, latitude, longitude, time):\n",
    "    \"\"\"Apply the naming convention to a group of urls\n",
    "    \n",
    "    Arguments:\n",
    "        urls: list of str, the photo urls\n",
    "        code: str, the photo sector code\n",
    "        latitude: float, the latitude\n",
    "        longitude: float, the longitude\n",
    "        time: datetime object, the measurement time\n",
    "        \n",
    "    Returns:\n",
    "        list of str, the filenames\n",
    "    \"\"\"\n",
    "    \n",
    "    # begin file name with protocol and latlon\n",
    "    base = 'GLOBEMHM_' + localize(latitude, longitude) + '_'\n",
    "    \n",
    "    # add the measurement time and sector code\n",
    "    base += time.strftime('%Y%m%dT%H%MZ') + '_' + code\n",
    "    \n",
    "    # add index and unique id\n",
    "    names = []\n",
    "    for index, url in enumerate(urls):\n",
    "        \n",
    "        # add index, starting with 1\n",
    "        name = base + str(index + 1)\n",
    "            \n",
    "        # add unique id and extension\n",
    "        unique = url.split('/')[-2]\n",
    "        name += '_' + unique + '.jpg'\n",
    "        names.append(name)\n",
    "        \n",
    "    return names"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('parsing photo urls')\n",
    "\n",
    "# dictionary of photo sector codes\n",
    "sectors = {'land cover': 'LC', 'tree height': 'TH'}\n",
    "\n",
    "# for each record\n",
    "for record in flats:\n",
    "\n",
    "    # initialize fields for each sector and parse urls\n",
    "    record['originals'] = []\n",
    "    record['thumbs'] = []\n",
    "    record['photos'] = []\n",
    "    for field, code in sectors.items():\n",
    "        \n",
    "        # split on semicolon, and keep all fragments with 'original'\n",
    "        datum = record[field] or ''\n",
    "        originals = [url.strip() for url in datum.split(';') if 'original' in url]\n",
    "        \n",
    "        # sort by the unique identifier as the number before the last slash\n",
    "        originals.sort(key=lambda url: url.split('/')[-2])\n",
    "        record['originals'] += originals\n",
    "        \n",
    "        # get the thumbnail versions\n",
    "        thumbs = [url.split('original')[0] + 'small.jpg' for url in originals]\n",
    "        record['thumbs'] += thumbs\n",
    "        \n",
    "        # apply the naming convention\n",
    "        photos = apply(originals, code, record['latitude'], record['longitude'], record['time'])\n",
    "        record['photos'] += photos\n",
    "        \n",
    "# status\n",
    "print('photo urls parsed.')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('viewing example flattened and abbreviated record')\n",
    "\n",
    "# view first record\n",
    "flats[0]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Removing Null Results"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('removing null results')\n",
    "\n",
    "# split nulls from the records so that only valid records are kept for analysis\n",
    "nulls = [record for record in flats if record['count'] is None]\n",
    "valids = [record for record in flats if record['count'] is not None]\n",
    "\n",
    "# raise assertion error on zero record\n",
    "try:\n",
    "    \n",
    "    # assert length > 0\n",
    "    assert len(valids) > 0\n",
    "    \n",
    "# otherwise\n",
    "except AssertionError:\n",
    "    \n",
    "    # raise the error with a message\n",
    "    message = '* Error! * No valid records returned'\n",
    "    raise Exception(message)\n",
    "    \n",
    "# sort records by time\n",
    "valids.sort(key=lambda record: str(record['time']))\n",
    "\n",
    "# count the number of these records\n",
    "print('{} valid records'.format(len(valids)))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Converting to Numbers"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('string conversion subroutine')\n",
    "\n",
    "# function to convert a string into a floating point number\n",
    "def convert(info):\n",
    "    \"\"\"Translate info given as a string or range of numbers into a numerical type.\n",
    "    \n",
    "    Arguments:\n",
    "        info: string\n",
    "        \n",
    "    Returns:\n",
    "        float\n",
    "    \"\"\"\n",
    "    \n",
    "    # try to convert directly\n",
    "    try:\n",
    "        \n",
    "        # translate to float\n",
    "        conversion = float(info)\n",
    "        \n",
    "    # otherwise\n",
    "    except ValueError:\n",
    "        \n",
    "        # try to convert a range of values to their average\n",
    "        try:\n",
    "        \n",
    "            # take the average, assuming a range separated by a hyphen\n",
    "            first, last = info.split('-')\n",
    "            first = float(first.strip())\n",
    "            last = float(last.strip())\n",
    "            conversion = float(first + last) / 2\n",
    "            \n",
    "        # otherwise\n",
    "        except ValueError:\n",
    "            \n",
    "            # scan for digits\n",
    "            digits = [character for character in info if character.isdigit()]\n",
    "            conversion = ''.join(digits)\n",
    "            conversion = float(conversion)\n",
    "        \n",
    "    return conversion"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#convert tree counts to numbers\n",
    "\n",
    "designate('converting all strings to numbers')\n",
    "\n",
    "# for each record\n",
    "for record in valids:\n",
    "    \n",
    "    # add the new field\n",
    "    record['tree'] = convert(record['count'])\n",
    "    \n",
    "# print status\n",
    "print('strings converted.')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Pruning Suspicious Outliers\n",
    "\n",
    "It is sometimes the case that records contain suspicous data. For instance, an entry of '1000000' for larvae counts is suspicous because likely no one counted one million larvae. These data can skew analysis and dwarf the rest of the data in graphs.\n",
    "The approach taken here is to calculate a \"z-score\" for each record. The z-score measures how many standard deviations the observation is from the mean of all observations. A highly negative or positive z-score, for instance 20, indicates an observation 20 standard deviations away from the mean. In a normal distribution, 99% of observations are found within 3 standard deviations, so an abnormally high z-score indicates a highly unlikely observation.\n",
    "The following function prunes away likely outliers by calculating z-scores and removing those above a threshold. With the outliers removed, new z-scores are calculated and the process continues until no more records get removed."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('outlier pruning subroutine')\n",
    "\n",
    "# function to prune away outlying observations\n",
    "def prune(records, threshold):\n",
    "    \"\"\"Prune away outlying observations based on a threshold z-score.\n",
    "    \n",
    "    Arguments:\n",
    "        records: list of dicts, the records\n",
    "        threshold: float, z-score threshold\n",
    "        \n",
    "    Returns:\n",
    "        tuple of two lists of dicts, (pruned records, outliers)\n",
    "    \"\"\"\n",
    "    \n",
    "    # prune until the length of records remains unchanged\n",
    "    outliers = []\n",
    "    number = len(records) + 1\n",
    "    while len(records) < number:\n",
    "        \n",
    "        # reset number of records\n",
    "        number = len(records)\n",
    "        \n",
    "        # calculate the z-score for each record\n",
    "        tree = [record['tree'] for record in records]\n",
    "        mean = average(larvae)\n",
    "        deviation = std(larvae)\n",
    "        for record in records:\n",
    "\n",
    "            # z-score is the absolute value of observation minus the mean, divided by the standard deviation\n",
    "            record['score'] = abs((record['tree'] - mean) / deviation)\n",
    "\n",
    "            # if the threshold is exceeded\n",
    "            if record['score'] >= threshold:\n",
    "\n",
    "                # append to outliers\n",
    "                outliers.append(record)\n",
    "            \n",
    "        # only retain records with z-scores below the threshold\n",
    "        records = [record for record in records if record['score'] < threshold]\n",
    "        \n",
    "    return records, outliers"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#set z-score threshold\n",
    "\n",
    "designate('setting z-score threshold', 'settings')\n",
    "\n",
    "# set z-score threshold, the number of standard deviations allowed\n",
    "threshold = 20\n",
    "\n",
    "\n",
    "\n",
    "designate('applying setting changes or propagating throughout notebook')\n",
    "\n",
    "# propagate changes\n",
    "propagate('### Pruning Suspicious Outliers', '### Filtering Records', '### Exporting to PDF')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#prune away outliers\n",
    "\n",
    "designate('pruning away outliers')\n",
    "\n",
    "# only prune valid authentics if more than two records\n",
    "authentics = valids\n",
    "outliers = []\n",
    "for record in authentics:\n",
    "    \n",
    "    # set zscores to 1\n",
    "    record['score'] = 1.0\n",
    "\n",
    "# find outliers\n",
    "if len(authentics) > 2:\n",
    "    \n",
    "    # prune outliers\n",
    "    authentics, outliers = prune(authentics, threshold)\n",
    "    \n",
    "# report each outlier\n",
    "print('z-score  larvae count')\n",
    "for outlier in outliers:\n",
    "    \n",
    "    # print\n",
    "    print(round(outlier['score'], 5), outlier['larvae'])\n",
    "    \n",
    "# report total\n",
    "print('\\n{} observations removed'.format(len(outliers)))\n",
    "print('{} records after removing outliers'.format(len(authentics)))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Construct a histogram of the larvae count size to examine the distribution. There are zooming tools at the right as well as a hover tool for inspecting individual columns.\n",
    "\n",
    "designate('gathering histogram data')\n",
    "\n",
    "# gather up tree observations\n",
    "observations = [record['tree'] for record in authentics]\n",
    "\n",
    "# set the width of each bar in larvae counts\n",
    "width = 5\n",
    "\n",
    "# calculate the number of histogram bins\n",
    "minimum = min(observations)\n",
    "maximum = max(observations)\n",
    "bins = int((maximum - minimum) / width) + 1\n",
    "\n",
    "# readjust maximum to cover an even number of bins\n",
    "maximum = minimum + bins * width\n",
    "\n",
    "# use numpy to get the counts and edges of each bin\n",
    "counts, edges = histogram(observations, bins=bins, range=(minimum, maximum))\n",
    "\n",
    "# calculate z-scores for each histogram bin\n",
    "scores = [round((edge - average(observations)) / std(observations), 2) for edge in edges[:-1]]\n",
    "\n",
    "# accumulate the info into a table\n",
    "table = ColumnDataSource({'counts': counts, 'left': edges[:-1], 'right': edges[1:], 'scores': scores})"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('setting overall histogram parameters')\n",
    "\n",
    "# create parameters dictionary for histogram labels\n",
    "parameters = {}\n",
    "parameters['title'] = 'Histogram of Tree Counts in {}'.format(country)\n",
    "parameters['x_axis_label'] = 'Tree Counts'\n",
    "parameters['y_axis_label'] = 'Number of Observations'\n",
    "\n",
    "# add plot size parameters\n",
    "parameters['plot_height'] = 400\n",
    "parameters['plot_width'] = 600\n",
    "\n",
    "# add initial zoom range at 5 standard deviations\n",
    "parameters['x_range'] = (0, int(std(observations)) * 5)\n",
    "\n",
    "# set the height of the graph to extend past the highest error bound\n",
    "parameters['y_range'] = (0, max(counts) + 10)\n",
    "\n",
    "# initialize the bokeh graph with the parameters\n",
    "gram = figure(**parameters)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('setting the bar parameters and annotations')\n",
    "\n",
    "# set parameters for drawing the bars, indicating the source of the data\n",
    "bars = {}\n",
    "bars['source'] = table\n",
    "\n",
    "# use the column headers to indicate the outline of each bar\n",
    "bars['bottom'] = 0\n",
    "bars['top'] = 'counts'\n",
    "bars['left'] = 'left'\n",
    "bars['right'] = 'right'\n",
    "\n",
    "# set the colors\n",
    "bars['line_color'] = 'white'\n",
    "bars['fill_color'] = 'lightgreen'\n",
    "\n",
    "# draw the bars with the quad plotting function\n",
    "gram.quad(**bars)\n",
    "\n",
    "# create annotations for the hover tool, where the @ is used in strings to refer to lists of data\n",
    "annotations = []\n",
    "annotations += [('Tree Counts Interval:', '(@left - @right)')]\n",
    "annotations += [('Number of Observations', '@counts')]\n",
    "annotations += [('Z-score', '@scores')]\n",
    "\n",
    "# activate the hover tool\n",
    "hover = HoverTool(tooltips=annotations)\n",
    "gram.add_tools(hover)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('displaying the histogram')\n",
    "\n",
    "# display\n",
    "output_notebook()\n",
    "show(gram)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('navigation buttons')\n",
    "\n",
    "# set navigation buttons\n",
    "navigate()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Filtering Records\n",
    "\n",
    "You may further filter the data if desired. Smaller datasets render more quickly, for instance. Set the criteria and click Apply to perform the filtering. You may set a parameter to None to avoid filtering by that parameter."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('setting filter parameters', 'settings')\n",
    "\n",
    "# set the specific genera of interest ['Anopheles', 'Aedes', 'Culex', 'Unknown', 'Other']\n",
    "# None defaults to all genera\n",
    "genera = ['dominant_genus', 'dominant_species', 'codominant_genus', 'codominant_species', 'mixed_dominant']\n",
    "\n",
    "# set minimum and maximum larvae counts or leave as None\n",
    "fewest = None\n",
    "most = None\n",
    "\n",
    "# set the inital or final date ranges (in 'YYYY-mm-dd' format), or leave as None\n",
    "initial = None\n",
    "final = None\n",
    "\n",
    "# set the latitude boundaries, or leave as None\n",
    "south = None\n",
    "north = None\n",
    "\n",
    "# set the longitude boundaries, or leave as None\n",
    "west = None\n",
    "east = None"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('applying setting changes or propagating throughout notebook')\n",
    "\n",
    "# propagate changes\n",
    "propagate('### Filtering Records', '### Grouping Observations by Time', '### Exporting to PDF')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('sifting data through filter', 'filtering')\n",
    "\n",
    "# function to sift data through filters\n",
    "def sift(records, parameters, fields, functions, symbols):\n",
    "    \"\"\"Sift records according to parameters.\n",
    "    \n",
    "    Arguments:\n",
    "        records: list of dicts\n",
    "        parameters: list of settings\n",
    "        fields: list of str\n",
    "        functions: list of function objects\n",
    "        symbols: list of str\n",
    "        \n",
    "    Returns:\n",
    "        list of dicts, str\n",
    "    \"\"\"\n",
    "    \n",
    "    # begin criteria string\n",
    "    criteria = ''\n",
    "\n",
    "    # filter primaries based on parameters\n",
    "    for parameter, field, function, symbol in zip(parameters, fields, functions, symbols):\n",
    "\n",
    "        # check for None\n",
    "        if parameter is not None:\n",
    "\n",
    "            # filter\n",
    "            if field in records[0].keys():\n",
    "            \n",
    "                # filter\n",
    "                records = [record for record in records if function(record[field], parameter)]\n",
    "\n",
    "                # add to criteria string\n",
    "                criteria += '{} {} {}\\n'.format(field, symbol, parameter)\n",
    "                \n",
    "    # sort data by date and add an index\n",
    "    records.sort(key=lambda record: record['date'])\n",
    "    [record.update({'index': index}) for index, record in enumerate(records)]\n",
    "\n",
    "    return records, criteria"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('filtering records')\n",
    "\n",
    "# set records to data\n",
    "records = [record for record in authentics]\n",
    "\n",
    "# make parameters and fields list\n",
    "parameters = [genera, fewest, most, initial, final, south, north, west, east]\n",
    "fields = ['genus', 'tree', 'tree', 'date', 'date', 'latitude', 'latitude', 'longitude', 'longitude']\n",
    "\n",
    "# make comparison functions list\n",
    "within = lambda value, setting: value in setting\n",
    "after = lambda value, setting: value >= datetime.strptime(str(setting), \"%Y-%m-%d\").date()\n",
    "before = lambda value, setting: value <= datetime.strptime(str(setting), \"%Y-%m-%d\").date()\n",
    "greater = lambda value, setting: value >= setting\n",
    "lesser = lambda value, setting: value <= setting\n",
    "\n",
    "# make associated functions\n",
    "functions = [within, greater, lesser, after, before, greater, lesser, greater, lesser]\n",
    "symbols = ['in', '>=', '<=', '>=', '<=', '>=', '<=', '>=', '<=']\n",
    "\n",
    "# filter primaries\n",
    "data, criteria = sift(authentics, parameters, fields, functions, symbols)\n",
    "formats = (len(data), len(authentics), mosquitoes, criteria)\n",
    "print('\\n{} of {} {} records meeting criteria:\\n\\n{}'.format(*formats))\n",
    "\n",
    "# set genera to classification by default\n",
    "genera = genera or classification"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('navigation buttons')\n",
    "\n",
    "# set navigation buttons\n",
    "navigate()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Grouping Observations by Time\n",
    "\n",
    "It may be useful to group the data by some time interval to study long term trends. Set the desired time interval in order to group the records. Possible values are 'year', 'month', 'week', and 'day'."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('setting the time interval', 'settings')\n",
    "\n",
    "# set time interval\n",
    "interval = 'week'\n",
    "\n",
    "#Click the Apply button to refresh the interval."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('applying setting changes or propagating throughout notebook')\n",
    "\n",
    "# propagate changes\n",
    "bookmarks = ['### Grouping Observations by Time', '### Plotting Larvae Counts over Time']\n",
    "bookmarks += ['### Grouping Observations by Time of Day']\n",
    "propagate(*bookmarks)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#group records into boxes based on chosen interval\n",
    "\n",
    "designate('partitioning data around time interval')\n",
    "\n",
    "# create normalization functions to round dates to the first of the month or year\n",
    "normalize = {}\n",
    "normalize['day'] = lambda date: date\n",
    "normalize['week'] = lambda date: date\n",
    "normalize['month'] = lambda date: date.replace(day=1)\n",
    "normalize['year'] = lambda date: date.replace(day=1).replace(month=1)\n",
    "\n",
    "# resolve function to pick the relevant date\n",
    "resolving = lambda first, second: datetime.strptime(str(first or second), \"%Y-%m-%d\").date()\n",
    "                                                   \n",
    "# zoom in on initial and final times from beginning and ending\n",
    "initial = resolving(initial, beginning)\n",
    "final = resolving(final, ending)\n",
    "\n",
    "# normalize initial and final dates\n",
    "initial = normalize[interval](initial)\n",
    "final = normalize[interval](final)\n",
    "\n",
    "# create incrementation functions to advance one time partition\n",
    "increment = {}\n",
    "increment['day'] = lambda box: box + timedelta(days=1)\n",
    "increment['week'] = lambda box: box + timedelta(weeks=1)\n",
    "increment['month'] = lambda box: (box + timedelta(weeks=5)).replace(day=1)\n",
    "increment['year'] = lambda box: (box + timedelta(weeks=53)).replace(day=1)\n",
    "\n",
    "# create boxes for each month\n",
    "boxes = {}\n",
    "box = initial\n",
    "while box <= final:\n",
    "    \n",
    "    # add box\n",
    "    boxes[box] = []\n",
    "    \n",
    "    # increment to get next box\n",
    "    box = increment[interval](box)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('sorting records into boxes')    \n",
    "    \n",
    "# for each record\n",
    "for record in data:\n",
    "    \n",
    "    # normalize the date record for the nearest box\n",
    "    box = normalize[interval](record['date'])\n",
    "    \n",
    "    # fit into appropriate box\n",
    "    unboxed = True\n",
    "    while unboxed:\n",
    "        \n",
    "        # try directly adding\n",
    "        try:\n",
    "            \n",
    "            # add to boxes\n",
    "            boxes[box].append(record)\n",
    "            unboxed = False\n",
    "            \n",
    "        # otherwise (if partitioning is in weeks)\n",
    "        except KeyError:\n",
    "            \n",
    "            # try using box based on previous day\n",
    "            box = box - timedelta(days=1)\n",
    "    \n",
    "# convert boxes to list and sort\n",
    "boxes = [item for item in boxes.items()]\n",
    "boxes.sort()\n",
    "\n",
    "# status\n",
    "print('\\ndata sorted into {} boxes by {}.'.format(len(boxes), interval))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('navigation buttons')\n",
    "\n",
    "# set navigation buttons\n",
    "navigate()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Plotting Tree Counts Over Time\n",
    "\n",
    "The following plots average tree counts over time, grouped according to the selected time interval. Standard deviations are also calculated and indicated with error bars."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('delineating bar graph bars subroutine')\n",
    "    \n",
    "# outline bar graph bars\n",
    "def delineate(boxes, increment, table, categorical=False, scale=1):\n",
    "    \"\"\"Delineate the graph bars.\n",
    "    \n",
    "    Arguments:\n",
    "        boxes: list of (number, list) tuples\n",
    "        increment: function to get rightmost point from left\n",
    "        table: dict\n",
    "        categorical=False: boolean, categorical variable?\n",
    "        scale: float, scale for whiskers\n",
    "        \n",
    "    Returns:\n",
    "        dict\n",
    "    \"\"\"\n",
    "    \n",
    "    # make samples column for number of samples in each box\n",
    "    table['size'] = [len(box[1]) for box in boxes]\n",
    "    \n",
    "    # make left column from data or from data indices if categorical\n",
    "    table['left'] = [(box[0], float(index))[int(categorical)] for index, box in enumerate(boxes)]\n",
    "    \n",
    "    # make right and middle columns from increment function\n",
    "    table['right'] = [increment(left) for left in table['left']]\n",
    "    table['middle'] = [left + (right - left) / 2 for left, right in zip(table['left'], table['right'])]\n",
    "    \n",
    "    # calculate averages and standard deviations, using [0.0] for default if empty\n",
    "    table['average'] = [average([record['larvae'] for record in box[1]] or [0.0]) for box in boxes]\n",
    "    table['deviation'] = [std([record['larvae'] for record in box[1]] or [0.0]) for box in boxes]\n",
    "    \n",
    "    # calculte upper and lower bounds for the error bars, using 1 /10 the standard deviation\n",
    "    table['upper'] = [height + (error / scale) for height, error in zip(table['average'], table['deviation'])]\n",
    "    table['lower'] = [height - (error / scale) for height, error in zip(table['average'], table['deviation'])]\n",
    "    \n",
    "    # set bottom at 0 and top at the average counts\n",
    "    table['bottom'] = [0.0 for box in boxes]\n",
    "    table['top'] = [entry for entry in table['average']]\n",
    "    \n",
    "    return table"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('parameterizing bars and error bars subroutine')\n",
    "\n",
    "# parameterize bars and error bar whiskers\n",
    "def parameterize(table, genus=None):\n",
    "    \"\"\"Parameterize the bar and error bar details for graphing.\n",
    "    \n",
    "    Arguments:\n",
    "        table: dict, the data\n",
    "        genus: str, the genus\n",
    "        \n",
    "    Returns:\n",
    "        dict, dict of bar parameters, whisker parameters\n",
    "    \"\"\"\n",
    "\n",
    "    # set the parameters for the bars in reference to the data table\n",
    "    color = indicators[genus]\n",
    "    bar = ({'source': table, 'x': 'middle', 'y': 'top', 'line_color': color, 'line_width': 4})\n",
    "    whisker = {'source': table, 'x': 'middle', 'line_color': color, 'line_width': 3, 'line_dash': 'dashed'}\n",
    "    whiskerii = whisker.copy()\n",
    "    whisker.update({'y': 'lower'})\n",
    "    whiskerii.update({'y': 'upper'})\n",
    "    whiskers = [whisker, whiskerii]\n",
    "    \n",
    "    # update with legend if available\n",
    "    if genus:\n",
    "        \n",
    "        # update bars and whiskers\n",
    "        bar.update({'legend_label': genus})\n",
    "        [whisker.update({'legend_label': genus}) for whisker in whiskers]\n",
    "\n",
    "    return bar, whiskers"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('gathering the dataset')\n",
    "\n",
    "# delineate columns\n",
    "table = delineate(boxes, increment[interval], {})\n",
    "\n",
    "# get maximum height\n",
    "height = max(table['upper'])\n",
    "\n",
    "# pack into a source\n",
    "table = ColumnDataSource(table)\n",
    "\n",
    "# get bar and whisker\n",
    "bar, whiskers = parameterize(table)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('setting the graph parameters')\n",
    "\n",
    "# set the graph label parameters\n",
    "parameters = {}\n",
    "parameters['title'] = 'Average Tree Counts per {} for {}'.format(interval, country)\n",
    "parameters['x_axis_label'] = 'Date'\n",
    "parameters['y_axis_label'] = 'Average Tree Count'\n",
    "\n",
    "# set the x-axis format as a datetime\n",
    "parameters['x_axis_type'] = 'datetime'\n",
    "\n",
    "# set the size of the graph parameters\n",
    "parameters['plot_height'] = 400\n",
    "parameters['plot_width'] = 800\n",
    "\n",
    "# set the height of the graph to extend past the highest error bound\n",
    "parameters['y_range'] = (0, height + 10)\n",
    "\n",
    "# Add annotations for the hover tool\n",
    "annotations = []\n",
    "annotations += [('Time Interval', '@left{%F} - @right{%F}')]\n",
    "annotations += [('Number of Observations', '@size')]\n",
    "annotations += [('Average Larvae Counts', '@average')]\n",
    "annotations += [('Standard Deviation', '@deviation')]\n",
    "\n",
    "# activate hover tool\n",
    "hover = HoverTool(tooltips=annotations, formatters={'left': 'datetime', 'right': 'datetime'})"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('drawing the graph')\n",
    "\n",
    "# draw the graph\n",
    "graph = figure(**parameters)\n",
    "graph.line(**bar)\n",
    "graph.circle(**bar)\n",
    "[graph.line(**whisker) for whisker in whiskers]\n",
    "graph.add_tools(hover)\n",
    "\n",
    "# show plot\n",
    "output_notebook()\n",
    "show(graph)\n",
    "\n",
    "#Note: Each point is potentially the average of several observations. The standard deviation is indicated by the dotted lines above and below the main plots."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('navigation buttons')\n",
    "\n",
    "# set navigation buttons\n",
    "navigate()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Plotting Tree Counts per Area\n",
    "\n",
    "If one of these tree genera cannot be identified, the genus is regarded as Other. And if the identification step is not performed, the genus is regarded as Unknown.  The following plots average larvae counts over time as above, but separated by genus."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('stacking bars subroutine')\n",
    "\n",
    "# stack collection of bars on top of each other\n",
    "def stack(tables):\n",
    "    \"\"\"Stack data tables on top of each other.\n",
    "    \n",
    "    Arguments:\n",
    "        tables: list of dicts\n",
    "        \n",
    "    Returns:\n",
    "        list of dicts, stacked tables\n",
    "    \"\"\"\n",
    "    \n",
    "    # default previous to zeroes\n",
    "    previous = [0.0] * len(tables[0]['average'])\n",
    "    \n",
    "    # adjust heights on each table\n",
    "    for table in tables:\n",
    "        \n",
    "        # raise bar heights according to previous bar heights\n",
    "        table['bottom'] = previous\n",
    "        table['top'] = [top + entry for top, entry in zip(table['top'], previous)]\n",
    "\n",
    "        # raise error bars by same amount\n",
    "        table['upper'] = [upper + entry for upper, entry in zip(table['upper'], previous)]\n",
    "        table['lower'] = [lower + entry for lower, entry in zip(table['lower'], previous)]\n",
    "\n",
    "        # update the new starting heights and maximum height\n",
    "        previous = [entry for entry in table['top']]\n",
    "        \n",
    "    return tables"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('gathering the datasets')\n",
    "\n",
    "# make data table for each genus\n",
    "tables = []\n",
    "for genus in genera:\n",
    "    \n",
    "    # retain only the subset of specific genera\n",
    "    subset = [(box[0], [record for record in box[1] if record['genus'] == genus]) for box in boxes]\n",
    "\n",
    "    # begin data columns with genus information\n",
    "    table = {}\n",
    "    table['genus'] = [genus] * len(subset)\n",
    "    \n",
    "    # delineate columns\n",
    "    table = delineate(subset, increment[interval], table)\n",
    "    tables.append(table)\n",
    "    \n",
    "# calculate maximum height of upper bars\n",
    "height = max([max(table['upper']) for table in tables])\n",
    "\n",
    "# create columns objects\n",
    "tables = [ColumnDataSource(table) for table in tables]\n",
    "\n",
    "# gather bar and whisker parameters\n",
    "gathering = [parameterize(table, genus) for table, genus in zip(tables, genera)]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('setting the graph parameters')\n",
    "\n",
    "# set the graph label parameters\n",
    "parameters = {}\n",
    "parameters['title'] = 'Average Larvae Counts per {} for {} per Genus'.format(interval, country)\n",
    "parameters['x_axis_label'] = 'Date'\n",
    "parameters['y_axis_label'] = 'Stacked Average Larvae Counts'\n",
    "\n",
    "# set the x-axis format as a datetime\n",
    "parameters['x_axis_type'] = 'datetime'\n",
    "\n",
    "# set the y-axis range\n",
    "parameters['y_range'] = (0, height + 10)\n",
    "\n",
    "# set the size of the graph parameters\n",
    "parameters['plot_height'] = 400\n",
    "parameters['plot_width'] = 800\n",
    "\n",
    "# Add annotations for the hover tool\n",
    "annotations = []\n",
    "annotations += [('Genus', '@genus')]\n",
    "annotations += [('Time Interval', '@left{%F} - @right{%F}')]\n",
    "annotations += [('Number of Observations', '@size')]\n",
    "annotations += [('Average Larvae Counts', '@average')]\n",
    "annotations += [('Standard Deviation', '@deviation')]\n",
    "\n",
    "# make hover tool\n",
    "hover = HoverTool(tooltips=annotations, formatters={'left': 'datetime', 'right': 'datetime'})"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('drawing the graph')\n",
    "\n",
    "# initialize the graph and draw the bars\n",
    "graph = figure(**parameters)\n",
    "[graph.line(**bar) for bar, _ in gathering]\n",
    "[graph.circle(**bar) for bar, _ in gathering]\n",
    "[[graph.line(**whisker) for whisker in whiskers] for _, whiskers in gathering]\n",
    "#[graph.add_layout(Whisker(**whisker)) for _, whisker in gathering]\n",
    "graph.add_tools(hover)\n",
    "graph.legend.click_policy='hide'\n",
    "\n",
    "# show plot\n",
    "output_notebook()\n",
    "show(graph)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Note: The correspondance between this graph and the above graph will only be approximate, because the first graph is plotting the average of all samples, whereas this graph is plotting the average per genus.  The sum of averages may differ from the average of sums.  The 'Other' category represents genus identified but not in the three of note, whereas the 'Unknown' category represents genus identification that has not been carred out.\n",
    "\n",
    "designate('navigation buttons')\n",
    "\n",
    "# set navigation buttons\n",
    "navigate()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Grouping Observations by Time of Day"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('setting the daypart interval', 'settings')\n",
    "\n",
    "# set length of hours interval\n",
    "hours = 1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('applying setting changes or propagating throughout notebook')\n",
    "\n",
    "# propagate changes\n",
    "bookmarks = ['### Grouping Observations by Time of Day', '### Plotting Larvae Counts by Water Source']\n",
    "bookmarks += ['### Plotting Larvae by Counts Water Source']\n",
    "propagate(*bookmarks)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('making boxes for each daypart interval')\n",
    "\n",
    "# use new year's as dummy date\n",
    "midnight = datetime(2020, 1, 1, 0)\n",
    "\n",
    "# create boxes for each month, starting with dummy date\n",
    "boxesii = {}\n",
    "box = midnight\n",
    "while box < midnight + timedelta(days=1):\n",
    "    \n",
    "    # add box\n",
    "    boxesii[box] = []\n",
    "    \n",
    "    # increment to get next box\n",
    "    box += timedelta(hours=hours)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('sorting records into boxes')\n",
    "\n",
    "# for each record\n",
    "for record in data:\n",
    "    \n",
    "    # center on dummy date of 1/1/2020 for datetime operations\n",
    "    box = record['hour'].replace(year=2020, month=1, day=1, minute=0)\n",
    "    \n",
    "    # fit into appropriate box\n",
    "    unboxed = True\n",
    "    while unboxed:\n",
    "        \n",
    "        # try directly adding\n",
    "        try:\n",
    "            \n",
    "            # add to boxes\n",
    "            boxesii[box].append(record)\n",
    "            unboxed = False\n",
    "            \n",
    "        # otherwise\n",
    "        except KeyError:\n",
    "            \n",
    "            # try using box based on previous hour\n",
    "            box = box - timedelta(hours=1)\n",
    "    \n",
    "# convert boxes to list and sort\n",
    "boxesii = [item for item in boxesii.items()]\n",
    "boxesii.sort()\n",
    "\n",
    "# status\n",
    "print('\\ndata sorted into {} boxes by {} hours each.'.format(len(boxesii), hours))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('gathering the datasets')\n",
    "\n",
    "# make data table for each genus\n",
    "tables = []\n",
    "for genus in genera:\n",
    "    \n",
    "    # retain only the subset of specific genera\n",
    "    subset = [(box[0], [record for record in box[1] if record['genus'] == genus]) for box in boxesii]\n",
    "\n",
    "    # begin data columns with genus information\n",
    "    table = {}\n",
    "    table['genus'] = [genus] * len(subset)\n",
    "    \n",
    "    # delineate columns\n",
    "    incrementing = lambda time: time + timedelta(hours=hours)\n",
    "    table = delineate(subset, incrementing, table)\n",
    "    tables.append(table)\n",
    "    \n",
    "# calculate maximum height of upper bars\n",
    "height = max([max(table['upper']) for table in tables])\n",
    "\n",
    "# create columns objects\n",
    "tables = [ColumnDataSource(table) for table in tables]\n",
    "\n",
    "# gather bar and whisker parameters\n",
    "gathering = [parameterize(table, genus) for table, genus in zip(tables, genera)]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('setting the graph parameters')\n",
    "\n",
    "# set the graph label bars\n",
    "parameters = {}\n",
    "parameters['title'] = 'Average Larvae Counts per {} hours for {} per Genus'.format(hours, country)\n",
    "parameters['x_axis_label'] = 'Time (solar local)'\n",
    "parameters['y_axis_label'] = 'Stacked Average Larvae Counts'\n",
    "\n",
    "# set the x-axis format as a datetime\n",
    "parameters['x_axis_type'] = 'datetime'\n",
    "\n",
    "# set the size of the graph bars\n",
    "parameters['plot_height'] = 400\n",
    "parameters['plot_width'] = 800\n",
    "\n",
    "# set height\n",
    "parameters['y_range'] = (0, height + 10)\n",
    "    \n",
    "# Add annotations for the hover tool\n",
    "annotations = []\n",
    "annotations += [('Genus', '@genus')]\n",
    "annotations += [('Number of Observations', '@size')]\n",
    "annotations += [('Average Larvae Counts', '@average')]\n",
    "annotations += [('Standard Deviation', '@deviation')]\n",
    "\n",
    "# activate hover tool\n",
    "hover = HoverTool(tooltips=annotations, formatters={'left': 'datetime', 'right': 'datetime'})"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('drawing the graph')\n",
    "\n",
    "# initialize the graph and draw the bars\n",
    "graph = figure(**parameters)\n",
    "graph.xaxis.formatter = DatetimeTickFormatter(days=\"%H:%M\", hours=\"%H:%M\")\n",
    "[graph.line(**bar) for bar, _ in gathering]\n",
    "[graph.circle(**bar) for bar, _ in gathering]\n",
    "[[graph.line(**whisker) for whisker in whiskers] for _, whiskers in gathering]\n",
    "#[graph.add_layout(Whisker(**whisker)) for _, whisker in gathering]\n",
    "graph.add_tools(hover)\n",
    "graph.legend.click_policy='hide'\n",
    "\n",
    "# show plot\n",
    "output_notebook()\n",
    "show(graph)\n",
    "\n",
    "#Note: Local times have been inferred by reference to the location's longitude (called local solar time). This may differ slightly from local time due to unusual time zone borders and daylight savings time adjustments."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('navigation buttons')\n",
    "\n",
    "# set navigation buttons\n",
    "navigate()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('gathering the datasets')\n",
    "\n",
    "# make data table for each genus\n",
    "tables = []\n",
    "for genus in genera:\n",
    "    \n",
    "    # retain only the subset of specific genera\n",
    "    subset = [(box[0], [record for record in box[1] if record['genus'] == genus]) for box in collection]\n",
    "\n",
    "    # begin data columns with genus information\n",
    "    table = {}\n",
    "    table['genus'] = [genus] * len(subset)\n",
    "    \n",
    "    # delineate columns\n",
    "    incrementing = lambda index: index + 1.0\n",
    "    table = delineate(subset, incrementing, table, categorical=True)\n",
    "    tables.append(table)\n",
    "    \n",
    "# calculate maximum height of upper bars\n",
    "height = max([max(table['upper']) for table in tables])\n",
    "\n",
    "# create columns objects\n",
    "tables = [ColumnDataSource(table) for table in tables]\n",
    "\n",
    "# gather bar and whisker parameters\n",
    "gathering = [parameterize(table, genus) for table, genus in zip(tables, genera)]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('drawing the graph')\n",
    "\n",
    "# initialize the graph and draw the bars\n",
    "graph = figure(**parameters)\n",
    "graph.xaxis.major_label_orientation = pi/4\n",
    "graph.xaxis.major_label_text_font_size = '10pt'\n",
    "[graph.line(**bar) for bar, _ in gathering]\n",
    "[graph.circle(**bar) for bar, _ in gathering]\n",
    "[[graph.line(**whisker) for whisker in whiskers] for _, whiskers in gathering]\n",
    "#[graph.add_layout(Whisker(**whisker)) for _, whisker in gathering]\n",
    "graph.add_tools(hover)\n",
    "graph.legend.click_policy='hide'\n",
    "\n",
    "# show plot\n",
    "output_notebook()\n",
    "show(graph)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('navigation buttons')\n",
    "\n",
    "# set navigation buttons\n",
    "navigate()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Plotting Sampling Locations on a Map\n",
    "\n",
    "The following plots all sample locations on a geographical map. This may take a little time depending on the size of the data set. The +/- are zoom controls, and the box below that enters full screen mode. Clicking on a sample will bring up a sample summary as well as all associated photos."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('fetching closest record subroutine')\n",
    "\n",
    "def fetch(latitude, longitude):\n",
    "    \"\"\"Fetch the closest record based on latitude and longitude\n",
    "    \n",
    "    Arguments:\n",
    "        latitude: float, latitude coordinate\n",
    "        longitude: float, longitude coordinate\n",
    "        \n",
    "    Returns:\n",
    "        dict, the closest record\n",
    "    \"\"\"\n",
    "    \n",
    "    # calculate the distances to all records\n",
    "    distances = []\n",
    "    for index, record in enumerate(data):\n",
    "        \n",
    "        # calculate squared distance\n",
    "        distance = (latitude - record['latitude']) ** 2 + (longitude - record['longitude']) ** 2\n",
    "        \n",
    "        # append to list\n",
    "        distances.append((index, distance))\n",
    "        \n",
    "    # sort by distance and choose closest\n",
    "    distances.sort(key=lambda pair: pair[1])\n",
    "    closest = distances[0][0]\n",
    "    \n",
    "    return closest"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('exhibiting photos on map subroutine')\n",
    "\n",
    "def exhibit(coordinates, chart, flags, thumbs=True):\n",
    "    \"\"\"Exhibit a record's photos on the map and add to photos list.\n",
    "    \n",
    "    Arguments:\n",
    "        coordinates: (float, float) tuple, the latitude and longitude\n",
    "        chart: ipyleaflets Map object\n",
    "        photos: list of photos so far\n",
    "        thumbs=True: boolean, use thumbnails?\n",
    "    \n",
    "    Returns:\n",
    "        None\n",
    "    \"\"\"\n",
    "\n",
    "    # fetch the closest record and add to flags\n",
    "    index = fetch(*coordinates)\n",
    "    flags.append(index)\n",
    "    record = data[index]\n",
    "    \n",
    "    # gather all photo urls depending on thumbnail setting\n",
    "    photos = record['thumbs'] if thumbs else record['originals']\n",
    "    \n",
    "    # send to output\n",
    "    layout = {'border': '1px solid blue', 'transparency': '50%', 'overflow_y': 'scroll', 'height': '200px'}\n",
    "    exhibitor = Output(layout=layout)\n",
    "    with exhibitor:\n",
    "            \n",
    "        # remove last set of photos\n",
    "        chart.controls = chart.controls[:5]\n",
    "        \n",
    "        # for each url\n",
    "        for photo in photos:\n",
    "\n",
    "            # paste the photo on the map\n",
    "            display(Image(photo, width=200, unconfined=True))\n",
    "\n",
    "    # add to map\n",
    "    control = WidgetControl(widget=exhibitor, position='bottomleft')\n",
    "    chart.add_control(control)\n",
    "    \n",
    "    return None"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('initializing map')\n",
    "\n",
    "# print status\n",
    "print('constructing map...')\n",
    "\n",
    "# get central latitude\n",
    "latitudes = [record['latitude'] for record in data]\n",
    "latitude = (max(latitudes) + min(latitudes)) / 2\n",
    "\n",
    "# get central longitude\n",
    "longitudes = [record['longitude'] for record in data]\n",
    "longitude = (max(longitudes) + min(longitudes)) / 2\n",
    "\n",
    "# set up map with topographical basemap zoomed in on center\n",
    "chart = Map(basemap=basemaps.Esri.WorldTopoMap, center=(latitude, longitude), zoom=5, double_click_zoom=False)\n",
    "\n",
    "# organize samples biggest first so smaller samples will be on top\n",
    "samples = [record for record in data]\n",
    "samples.sort(key=lambda record: record['score'], reverse=True)\n",
    "\n",
    "# begin flags list and record list\n",
    "flags = []"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('creating sample markers')\n",
    "\n",
    "# create marker layer\n",
    "markers = []\n",
    "for record in samples:\n",
    "    \n",
    "    # unpack record\n",
    "    latitude = record['latitude']\n",
    "    longitude = record['longitude']\n",
    "    larvae = record['larvae']\n",
    "    genus = record['genus']\n",
    "    date = record['date']\n",
    "    score = record['score']\n",
    "    \n",
    "    # add sample marker\n",
    "    circle = CircleMarker()\n",
    "    circle.location = (latitude, longitude)\n",
    "    \n",
    "    # set color attributes\n",
    "    circle.weight = 1\n",
    "    circle.color = 'black'\n",
    "    circle.fill = True\n",
    "    circle.opacity = 0.8\n",
    "    circle.fill_color = indicators[genus]\n",
    "    \n",
    "    # set radius as a function of z-score (relative larvae count)\n",
    "    circle.radius = int(sqrt(score) + 1) * 5\n",
    "    \n",
    "    # exhibit photo on map for click\n",
    "    exhibiting = lambda **event: exhibit(event['coordinates'], chart, flags, thumbs=True)\n",
    "    circle.on_click(exhibiting)\n",
    "    \n",
    "    # annotate marker with popup label\n",
    "    formats = (int(larvae), genus, date, latitude, longitude)\n",
    "    message = 'Larvae: {}, Genus: {}, Date: {}, Latitude: {}, Longitude: {}'.format(*formats)\n",
    "    circle.popup = HTML(message)\n",
    "    \n",
    "    # add to markers layer\n",
    "    markers.append(circle)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('constructing map')\n",
    "\n",
    "# add marker layer\n",
    "group = LayerGroup(layers=markers)\n",
    "chart.add_layer(group)\n",
    "\n",
    "# add full screen control\n",
    "chart.add_control(FullScreenControl())\n",
    "\n",
    "# add genus legend\n",
    "labels = [Label(value = r'\\(\\color{' + 'black' +'} {' + 'Genera:'  + '}\\)')]\n",
    "labels += [Label(value = r'\\(\\color{' + indicators[genus] +'} {' + genus  + '}\\)') for genus in genera]\n",
    "legend = VBox(labels)\n",
    "\n",
    "# send to output\n",
    "cartographer = Output(layout={'border': '1px solid blue', 'transparency': '50%'})\n",
    "with cartographer:\n",
    "    \n",
    "    # display legent\n",
    "    display(legend)\n",
    "\n",
    "# add to map\n",
    "control = WidgetControl(widget=cartographer, position='topright')\n",
    "chart.add_control(control)\n",
    "\n",
    "# add full screen button and map scale\n",
    "chart.add_control(ScaleControl(position='topleft'))\n",
    "\n",
    "# display the map\n",
    "chart"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('navigation buttons')\n",
    "\n",
    "# set navigation buttons\n",
    "navigate()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Viewing Photos\n",
    "\n",
    "Clicking on the View button below will view the first fifteen photos in a scrollable window. Clicking on the left side of the window will expand the view. The export option in the next section may be used to download the full set of photos."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('summarizing record subroutine')\n",
    "\n",
    "# print a record summary\n",
    "def summarize(record):\n",
    "    \"\"\"Summarize the record.\n",
    "    \n",
    "    Arguments:\n",
    "        record: dict\n",
    "        \n",
    "    Returns:\n",
    "        None\n",
    "    \"\"\"\n",
    "    \n",
    "    # print record summary\n",
    "    print(' ')\n",
    "    print(' ')\n",
    "    print('date: {}'.format(record['date']))\n",
    "    print('latitude: {}'.format(record['latitude']))\n",
    "    print('longitude: {}'.format(record['longitude']))\n",
    "    print('larvae count: {}'.format(record['larvae']))\n",
    "    print('genus: {}'.format(record['genus']))\n",
    "    \n",
    "    return None"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('segregating records subroutine')\n",
    "\n",
    "# function to segregate records\n",
    "def segregate():\n",
    "    \"\"\"Segregate the records into those flagged and those remaining.\n",
    "    \n",
    "    Arguments:\n",
    "        flags: list of ints, the flagged records\n",
    "        \n",
    "    Returns:\n",
    "        list of ints\n",
    "    \"\"\"\n",
    "    \n",
    "    # get chosen records and remaining records, linking them to their indices\n",
    "    chosen = [number for index, number in enumerate(flags) if flags.index(number) == index]\n",
    "    remainder = [number for number, _ in enumerate(data) if number not in chosen]\n",
    "    ids = chosen + remainder\n",
    "    \n",
    "    return ids"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('viewing photos')\n",
    "\n",
    "# add button click command\n",
    "scrapbook = Output()\n",
    "button = Button(description='View')\n",
    "display(button, scrapbook)\n",
    "\n",
    "# function to export to csv\n",
    "def view(_):\n",
    "    \"\"\"Retrieve all flagged photos and print them to screen.\n",
    "    \n",
    "    Arguments:\n",
    "        None\n",
    "        \n",
    "    Returns:\n",
    "        None\n",
    "    \"\"\"\n",
    "    \n",
    "    # get ids list\n",
    "    ids = segregate()\n",
    "    \n",
    "    # count total number of photos\n",
    "    lengths = [len(data[number]['originals']) for number in ids]\n",
    "    total = sum(lengths)\n",
    "    \n",
    "    # find cutoff point\n",
    "    quantity = 0\n",
    "    cutoff = 0\n",
    "    while quantity < 15 and cutoff < len(ids):\n",
    "        \n",
    "        # increment index\n",
    "        cutoff += 1\n",
    "        quantity = sum(lengths[:cutoff])\n",
    "        \n",
    "    # print\n",
    "    print('displaying {} photos of {} total photos in {} records'.format(quantity, total, len(ids)))\n",
    "    \n",
    "    # go through top fifty records\n",
    "    for index in ids[:cutoff]:\n",
    "        \n",
    "        # check through all photos\n",
    "        record = data[index]\n",
    "        summarize(record)\n",
    "        for original, photo in zip(record['originals'], record['photos']):\n",
    "\n",
    "            # display photo\n",
    "            print(' ')\n",
    "            print('url: {}'.format(original))\n",
    "            print('file: {}'.format(photo))\n",
    "            display(Image(original, width=800))\n",
    "\n",
    "    return None\n",
    "\n",
    "# add click \n",
    "button.on_click(view)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('navigation buttons')\n",
    "\n",
    "# set navigation buttons\n",
    "navigate()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Exporting Photos"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('exporting photos to zip file')\n",
    "\n",
    "# function to export to zip file\n",
    "def archive(_):\n",
    "    \"\"\"Archive all photos into a zip drive.\n",
    "    \n",
    "    Arguments:\n",
    "        None\n",
    "        \n",
    "    Returns:\n",
    "        None\n",
    "    \"\"\"\n",
    "\n",
    "    # begin zip file and go through records\n",
    "    album = ZipFile('mosquitoes_photos.zip', 'w')\n",
    "    print('{} records:'.format(len(data)), end='')\n",
    "    for record in data:\n",
    "        \n",
    "        # upload photos\n",
    "        print('.', end='')\n",
    "        for photo, original in zip(record['photos'], record['originals']):\n",
    "\n",
    "            # get original and pass to file\n",
    "            request = requests.get(original, stream=True)\n",
    "            with open(photo, 'wb') as pointer: [pointer.write(chunk) for chunk in request]\n",
    "            album.write(photo)\n",
    "            os.remove(photo)\n",
    "                    \n",
    "    # close zip file and make link\n",
    "    print('')\n",
    "    album.close()\n",
    "    link = FileLink('mosquitoes_photos.zip')\n",
    "    archiver.append_display_data(link)\n",
    "\n",
    "    return None\n",
    "\n",
    "# create push button linked to output\n",
    "archiver = Output()\n",
    "button = Button(description='Zip')\n",
    "display(button, archiver)\n",
    "button.on_click(archive)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('navigation buttons')\n",
    "\n",
    "# set navigation buttons\n",
    "navigate()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Viewing the Records"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('viewing the searched records')\n",
    "\n",
    "# create push button linked to output\n",
    "window = Output()\n",
    "button = Button(description='View')\n",
    "display(button, window)\n",
    "\n",
    "# view records\n",
    "def view(_):\n",
    "    \"\"\"View all records.\n",
    "    \n",
    "    Arguments:\n",
    "        None\n",
    "        \n",
    "    Returns:\n",
    "        None\n",
    "    \"\"\"\n",
    "\n",
    "    # get chosen records and remaining records, linking them to their indices\n",
    "    chosen = [number for index, number in enumerate(flags) if flags.index(number) == index]\n",
    "    remainder = [number for number, _ in enumerate(data) if number not in chosen]\n",
    "\n",
    "    # list records\n",
    "    for index in chosen + remainder:\n",
    "\n",
    "        # print to screen\n",
    "        print('\\nrecord {} of {}:'.format(index, len(data)))\n",
    "        features = [item for item in data[index].items()]\n",
    "        features.sort(key=lambda feature: feature[0])\n",
    "        features.sort(key=lambda feature: len(feature[0]))\n",
    "        for field, datum in features:\n",
    "\n",
    "            # print each field\n",
    "            print('{}: {}'.format(field, datum))\n",
    "        \n",
    "# add button click command\n",
    "button.on_click(view)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('navigation buttons')\n",
    "\n",
    "# set navigation buttons\n",
    "navigate()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Viewing the Data Table\n",
    "\n",
    "Can be viewed and organized by date"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('viewing the data table')\n",
    "\n",
    "# set options for viewing full columns\n",
    "pandas.set_option(\"display.max_rows\", None)\n",
    "pandas.set_option(\"display.max_columns\", None)\n",
    "\n",
    "# create dataframe from data\n",
    "panda = pandas.DataFrame(data)\n",
    "\n",
    "# reorder columns according to length of field\n",
    "columns = [field for field in panda.columns]\n",
    "columns.sort(key=lambda field: field)\n",
    "columns.sort(key=lambda field: len(field))\n",
    "panda = panda[columns]\n",
    "\n",
    "# display in output\n",
    "panda"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('navigation buttons')\n",
    "\n",
    "# set navigation buttons\n",
    "navigate()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Exporting Data to CSV"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('exporting data to csv')\n",
    "\n",
    "# create push button linked to output\n",
    "exporter = Output()\n",
    "button = Button(description='Export')\n",
    "display(button, exporter)\n",
    "\n",
    "# function to export to zip file\n",
    "def export(_):\n",
    "    \"\"\"Export the data as a csv file.\n",
    "    \n",
    "    Arguments:\n",
    "        None\n",
    "        \n",
    "    Returns:\n",
    "        None\n",
    "    \"\"\"\n",
    "\n",
    "    # create dataframe from data\n",
    "    panda = pandas.DataFrame(data)\n",
    "    \n",
    "    # reorder columns according to length of field\n",
    "    columns = [field for field in panda.columns]\n",
    "    columns.sort(key=lambda field: field)\n",
    "    columns.sort(key=lambda field: len(field))\n",
    "    panda = panda[columns]\n",
    "    \n",
    "    #write dataframe to file\n",
    "    panda.to_csv(\"mosquitoes.csv\")  \n",
    "    \n",
    "    # make link\n",
    "    link = FileLink('mosquitoes.csv')\n",
    "    \n",
    "    # add to output\n",
    "    exporter.append_display_data(link)\n",
    "\n",
    "    return None\n",
    "\n",
    "# add button click command\n",
    "button.on_click(export)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('navigation buttons')\n",
    "\n",
    "# set navigation a\n",
    "navigate()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Exporting to PDF\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('generating pdf')\n",
    "\n",
    "# function to generate pdf\n",
    "def generate(_):\n",
    "    \"\"\"Export the data into a csv file.\n",
    "\n",
    "    Arguments:\n",
    "        None\n",
    "\n",
    "    Returns:\n",
    "        None\n",
    "    \"\"\"\n",
    "\n",
    "    # make pdf\n",
    "    display(Javascript('window.print()'))\n",
    "    \n",
    "    return None\n",
    "\n",
    "# add button click command\n",
    "button = Button(description='Generate')\n",
    "display(button)\n",
    "button.on_click(generate)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "designate('navigation buttons')\n",
    "\n",
    "# set navigation buttons\n",
    "navigate()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Thank you note --> mathew.bandel@ssaihg.com\n",
    "\n",
    "# button for navigation\n",
    "navigate()"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
